




	OpenMPを用いた探索の高速化

			矢倉大夢






　四則とは


	n個の整数を使って
	四則演算だけで10を作る


	(1,1,5,8) 
		→  8/(1-1/5)=10



　例題


	(2,10,12,19,23,48,93)

	→






　例題


	(2,10,12,19,23,48,93)

	→ (23-48+19)*12*93/93+10+2=10


	n>4の時は脳内でとくのは
	なかなか大変


　四則ソルバー


	「四則」を「解く」


	intを超えない範囲なら
	nをいくらでも増やせる




　性能


	0-19の整数が5つ
	すべての組み合わせ
	42504個	44.61秒






　探索方法


	計算結果の後ろ側から
	探索することで
	オーダーを減らしている

	基本的に再帰で探索している




　並列化する


	再帰呼び出しをするたびに
	スレッドを追加する







　並列化する


	再帰呼び出しをするたびに
	スレッドを追加する


	プロセッサー数に対し
	スレッドが多すぎると
	オーバーヘッドが大きい


　効率的な並列化


	再帰の深さによって
	スレッドの生成を制限







　効率的な並列化


	再帰の深さによって
	スレッドの生成を制限

	うまく動かなかったり
	調整が難しかったりして
	徹夜でRedbullとともに
	チューニングしてました


　速くなったのか


	3≦ n≦ 15 0≦ i≦ n
	0≦ numbers[i]≦ 20

	上を満たすデータを
	10000個用意して
	演算させる



　結果


	OpenMPなし:
		55.44秒

	OpenMPあり(2コア):
		34.75秒




　結果


	約1.5倍高速化


	コアを2倍にして
	演算速度が1.5倍というのは
	だいぶ効率がよい(？)



　まとめ


	あんまり深く考えずに
	並列化しようとすると
	バグとか不正アクセスに
	悩まされることになるので
	注意！




　まとめ


	これからはクラスメートに
	四則を出されても
	SSHでサーバーに接続することが
	出来れば問題ない！


	これで勝つる！！！






	ご清聴ありがとうございました







